rm(list=ls())
##install.packages("HGDP.CEPH", repos="https://genostats.github.io/R/")
require(HGDP.CEPH)
# lire données
filepath <-system.file("extdata", "hgdp_ceph.bed", package="HGDP.CEPH")
x <- read.bed.matrix(filepath)
# données SNP et individus
head( x@snps )
head( x@ped )
# comment les régions sont recodées en 7 grandes régions
table(x@ped$region, x@ped$region7)
# ajouter callrate, maf, etc
x <- set.stats(x)
# virer SNPs rares et non-autosomaux
x <- select.snps(x, maf > 0.05 & is.autosome(chr))
# calcul matrice de corrélation inter individus
K.x <- GRM(x)
# eigen decomposition
eigen.K.x <- eigen(K.x)
dim(eigen.K.x$vectors)
# ébouli des valeurs propres
plot( eigen.K.x$values)
# % variance 4 premières PCs
cumsum( eigen.K.x$values)[2]/sum(eigen.K.x$values)
# deux premières PCs + régions
plot( eigen.K.x$vectors, col = x@ped$region7)
?eingen
?eigen
head( x@ped )
# comment les régions sont recodées en 7 grandes régions
table(x@ped$region, x@ped$region7)
# eigen decomposition
eigen.K.x <- eigen(K.x)
rm(list=ls())
##install.packages("HGDP.CEPH", repos="https://genostats.github.io/R/")
require(HGDP.CEPH)
require(VarSelLCM)
# lire données
filepath <-system.file("extdata", "hgdp_ceph.bed", package="HGDP.CEPH")
x <- read.bed.matrix(filepath)
# données SNP et individus
head( x@snps )
head( x@ped )
# comment les régions sont recodées en 7 grandes régions
table(x@ped$region, x@ped$region7)
# ajouter callrate, maf, etc
x <- set.stats(x)
# virer SNPs rares et non-autosomaux
x <- select.snps(x, maf > 0.05 & is.autosome(chr))
# calcul matrice de corrélation inter individus
K.x = GRM(x)
# eigen decomposition
eigen.K.x <- eigen(K.x)
# ébouli des valeurs propres
plot( eigen.K.x$values)
km.acp <- kmeans(eigen.K.x$vectors[,1:2], centers=d, nstart=500)
km.acp <- kmeans(eigen.K.x$vectors[,1:2], centers=7, nstart=500)
table(km.acp$cluster, x@ped$region7)
ARI(km.acp$cluster, x@ped$region7)
km.acp <- kmeans(eigen.K.x$vectors[,1:2], centers=7, nstart=500)
table(km.acp$cluster, x@ped$region7)
ARI(km.acp$cluster, x@ped$region7)
# clustering spectral
W = sqrt(pmax((K.x%*%t(K.x)),0))
km.acp <- kmeans(eigen.K.x$vectors[,1:3], centers=7, nstart=500)
table(km.acp$cluster, x@ped$region7)
ARI(km.acp$cluster, x@ped$region7)
km.acp <- kmeans(eigen.K.x$vectors[,1:2], centers=7, nstart=500)
table(km.acp$cluster, x@ped$region7)
ARI(km.acp$cluster, x@ped$region7)
unlink('mspes_cache', recursive = TRUE)
library(keras)
install.packages("keras")
require(keras)
mnist <- dataset_mnist()
x_train <- mnist$train$x
y_train <- mnist$train$y
dim(x)
dim(x_train)
x_train[1,,]
par(mfcol=c(6,6))
par(mar=c(0, 0, 3, 0), xaxs='i', yaxs='i')
for (idx in 1:36) {
im <- x_train[idx,,,1]
im <- t(apply(im, 2, rev))
image(1:28, 1:28, im, col=gray((0:255)/255),
xaxt='n', main=paste(y_train[idx]))
}
# visualize the digits
par(mfcol=c(6,6))
par(mar=c(0, 0, 3, 0), xaxs='i', yaxs='i')
for (idx in 1:36) {
im <- x_train[idx,,1]
im <- t(apply(im, 2, rev))
image(1:28, 1:28, im, col=gray((0:255)/255),
xaxt='n', main=paste(y_train[idx]))
}
# visualize the digits
par(mfcol=c(6,6))
par(mar=c(0, 0, 3, 0), xaxs='i', yaxs='i')
for (idx in 1:36) {
im <- x_train[idx,,]
im <- t(apply(im, 2, rev))
image(1:28, 1:28, im, col=gray((0:255)/255),
xaxt='n', main=paste(y_train[idx]))
}
require(keras)
mnist <- dataset_mnist()
x_train <- mnist$train$x
y_train <- mnist$train$y
x_test  <- mnist$test$x
y_test  <- mnist$test$y
# visualize the digits
par(mfcol=c(6,6))
par(mar=c(0, 0, 3, 0), xaxs='i', yaxs='i')
for (idx in 1:36) {
im <- x_train[idx,,]
im <- t(apply(im, 2, rev))
image(1:28, 1:28, im, col=gray((0:255)/255),
xaxt='n', main=paste(y_train[idx]))
}
dim(x_test)
require(dplyr)
require(caret)
require(neuralnet)
require(e1071)
xm_train <- matrix(xm_train, dim(x_train)[1], 28**2)
xm_train <- matrix(xm_train, dim(x_train)[1], 28**2)
xm_train <- matrix(x_train, dim(x_train)[1], 28**2)
xm[1,]
xm_train[1,]
xm_train[1,1:28]
x_train[1,,1]
xm_train[1,29:56]
x_train[1,,]
xm_train <- matrix(x_train, dim(x_train)[1], 28**2, byrow = F)
x_train[1,,]
xm_train[1,]
y_train.freq <- table(y_train)
barplot(y_train.freq)
barplot(y_train.freq)
28**2
?nearZeroVar
?preProcess
## suppression et réduction de dimensions
nzv <- nearZeroVar(xm_train)
dim(xm_train)
xm_nzv_train <- dftrain.pixel[,-nzv]
xm_nzv_train <- xm_train[,-nzv]
dim(xm_nzv_train)
preProcValues <- preProcess(xm_nzv_train, method=c("pca"))
xm_train_tr <- predict(preProcValues, xm_nzv_train)
xm_nzv_train <- xm_train[,-nzv]
dim(xm_nzv_train)
preProcValues <- preProcess(xm_nzv_train, method=c("pca"))
xm_nzv_train[1:10,1:10]
colnames(xm_nzv_train) <- paste("x", 1:ncol(xm_nzv_train), sep="")
preProcValues <- preProcess(xm_nzv_train, method=c("pca"))
xm_train_tr <- predict(preProcValues, xm_nzv_train)
dim(xm_train_tr)
nzv <- nearZeroVar(xm_test)
xm_test <- matrix(x_test, dim(x_test)[1], 28**2)
y_test  <- mnist$test$y
nzv <- nearZeroVar(xm_test)
dim(xm_test)
dim(xm_test)
dim(xm_test)
xm_nzv_test <- xm_test[,-nzv]
dim(xm_nzv_test)
colnames(xm_nzv_test) <- paste("x", 1:ncol(xm_nzv_test), sep="")
preProcValues <- preProcess(xm_nzv_test, method=c("pca"))
xm_test_tr <- predict(preProcValues, xm_nzv_train)
xm_test_tr <- predict(preProcValues, xm_nzv_test)
dim(xm_test_tr)
## suppression et réduction de dimensions
x <- rbind(x_train, x_test)
nzv <- nearZeroVar(x)
#nzv <- nearZeroVar(x)
x <- x[, -(colSums(x)==0)]
dim(x)
## suppression et réduction de dimensions
x <- cbind(x_train, x_test)
dim(x)
## suppression et réduction de dimensions
xm <- rbind(xm_train, xm_test)
dim(xm)
#nzv <- nearZeroVar(x)
xm <- xm[, -(colSums(x)==0)]
dim(xm)
nzv <- nearZeroVar(xm)
## suppression et réduction de dimensions
xm <- rbind(xm_train, xm_test)
nzv <- nearZeroVar(xm)
xm <- xm[, -nvz]
xm <- xm[, -nzv]
dim(xm)
xm_nzv_train <- xm_train[1:60000,]
xm_nzv_train <- xm[1:60000,]
dim(xm_nzv_train)
colnames(xm_nzv_train) <- paste("x", 1:ncol(xm_nzv_train), sep="")
preProcValues <- preProcess(xm_nzv_train, method=c("pca"))
xm_train_tr <- predict(preProcValues, xm_nzv_train)
dim(xm_train_tr)
xm_nzv_test <- xm[,-nzv]
dim(xm_nzv_test)
## suppression et réduction de dimensions
xm <- rbind(xm_train, xm_test)
xm <- xm[, -nzv]
xm_nzv_test <- xm[60001:70000,]
dim(xm_nzv_test)
colnames(xm_nzv_test) <- paste("x", 1:ncol(xm_nzv_test), sep="")
preProcValues <- preProcess(xm_nzv_test, method=c("pca"))
xm_test_tr <- predict(preProcValues, xm_nzv_test)
dim(xm_test_tr)
?predict.preProcess
## suppression et réduction de dimensions
xm <- rbind(xm_train, xm_test)
xm <- xm[, -nzv]
dim(xm)
#xm_nzv_train <- xm[1:60000,]
#dim(xm_nzv_train)
colnames(xm) <- paste("x", 1:ncol(xm), sep="")
preProcValues <- preProcess(xm, method=c("pca"))
xm_train_tr <- xm_tr[1:60000,]
xm_tr <- predict(preProcValues, xm)
dim(xm_tr)
xm_train_tr <- xm_tr[1:60000,]
xm_test_tr  <- xm_tr[60001:70000,]
dim(xm_train_tr)
dim(xm_test_tr)
## caret pour svm et RF
fitControl <- trainControl(method = 'repeatedcv',
number = 5,
repeats = 5)
trainWrapper <- function(modelType, fitControl, trainData) {
set.seed(99)  # helpful for reproducibility
startTime <- Sys.time()
model <- train(label ~ ., data = trainData,
method = modelType,
trControl = fitControl)
endTime <- Sys.time()
trainingTime <- endTime - startTime
print(paste(modelType, " training time:", trainingTime))
return(model)
}
#require(neuralnet)
require(doParallel)
## caret pour svm et RF
fitControl <- trainControl(method = 'repeatedcv',
number = 5,
repeats = 5)
trainWrapper <- function(modelType, fitControl, trainData) {
cl <- makePSOCKcluster(8)
registerDoParallel(cl)
set.seed(99)  # helpful for reproducibility
startTime <- Sys.time()
model <- train(label ~ ., data = trainData,
method = modelType,
trControl = fitControl)
endTime <- Sys.time()
trainingTime <- endTime - startTime
stopCluster(cl)
print(paste(modelType, " training time:", trainingTime))
return(model)
}
?train
rf <- trainWrapper('rf', fitControl, smallTrain)
is.factor(y_test)
trainWrapper <- function(modelType, fitControl, y, x) {
cl <- makePSOCKcluster(8)
registerDoParallel(cl)
set.seed(99)  # helpful for reproducibility
startTime <- Sys.time()
model <- train(y ~ x,
method = modelType,
trControl = fitControl)
endTime <- Sys.time()
trainingTime <- endTime - startTime
stopCluster(cl)
print(paste(modelType, " training time:", trainingTime))
return(model)
}
rf <- trainWrapper('rf', fitControl, y_train, xm_train_tr)
trainWrapper <- function(modelType, fitControl, y, x) {
cl <- makePSOCKcluster(8)
registerDoParallel(cl)
set.seed(99)  # helpful for reproducibility
startTime <- Sys.time()
model <- train(y ~ x,
method = modelType,
metric = "Accuracy",
trControl = fitControl)
endTime <- Sys.time()
trainingTime <- endTime - startTime
stopCluster(cl)
print(paste(modelType, " training time:", trainingTime))
return(model)
}
rf <- trainWrapper('rf', fitControl, y_train, xm_train_tr)
y_train
dim(y_train)
rf <- trainWrapper('rf', fitControl, y_train, xm_train_tr)
?trainControl
